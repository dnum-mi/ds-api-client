type Address {
  # code INSEE de la commune
  cityCode: String!

  # nom de la commune
  cityName: String!

  # n° de département
  departmentCode: String

  # nom de département
  departmentName: String

  # coordonnées géographique
  geometry: GeoJSON

  # libellé complet de l’adresse
  label: String!

  # code postal
  postalCode: String!

  # n° de region
  regionCode: String

  # nom de région
  regionName: String

  # numéro éventuel et nom de voie ou lieu dit
  streetAddress: String

  # nom de voie ou lieu dit
  streetName: String

  # numéro avec indice de répétition éventuel (bis, ter, A, B)
  streetNumber: String

  # type de résultat trouvé
  type: AddressType!
}

type AddressChamp implements Champ {
  address: Address
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

enum AddressType {
  # numéro « à la plaque »
  housenumber

  # position « à la voie », placé approximativement au centre de celle-ci
  street

  # numéro « à la commune »
  municipality

  # lieu-dit
  locality
}

type Association {
  dateCreation: ISO8601Date
  dateDeclaration: ISO8601Date
  datePublication: ISO8601Date
  objet: String
  rna: String!
  titre: String!
}

type Avis {
  attachment: File
  claimant: Profile
  dateQuestion: ISO8601DateTime!
  dateReponse: ISO8601DateTime
  expert: Profile
  id: ID!
  instructeur: Profile!
    @deprecated(reason: "Utilisez le champ `claimant` à la place.")
  question: String!
  reponse: String
}

# Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
scalar BigInt

type CarteChamp implements Champ {
  geoAreas: [GeoArea!]!
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

interface Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

type ChampDescriptor {
  # Description des champs d’un bloc répétable.
  champDescriptors: [ChampDescriptor!]

  # Description du champ.
  description: String
  id: ID!

  # Libellé du champ.
  label: String!

  # List des options d’un champ avec selection.
  options: [String!]

  # Est-ce que le champ est obligatoire ?
  required: Boolean!

  # Type de la valeur du champ.
  type: TypeDeChamp!
}

type CheckboxChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
  value: Boolean!
}

enum Civilite {
  # Monsieur
  M

  # Madame
  Mme
}

type CiviliteChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
  value: Civilite
}

type Commune {
  # Le code INSEE
  code: String!
  name: String!
}

type CommuneChamp implements Champ {
  commune: Commune
  departement: Departement
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

# GeoJSON coordinates
scalar Coordinates

# Autogenerated input type of CreateDirectUpload
input CreateDirectUploadInput {
  # Dossier ID
  dossierId: ID!

  # Original file name
  filename: String!

  # File size (bytes)
  byteSize: Int!

  # MD5 file checksum as base64
  checksum: String!

  # File content type
  contentType: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateDirectUpload
type CreateDirectUploadPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  directUpload: DirectUpload!
}

type DateChamp implements Champ {
  # La valeur du champ formaté en ISO8601 (Date).
  date: ISO8601Date
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String

  # La valeur du champ formaté en ISO8601 (DateTime).
  value: ISO8601DateTime
    @deprecated(
      reason: "Utilisez le champ `date` ou le fragment `DatetimeChamp` à la place."
    )
}

type DatetimeChamp implements Champ {
  # La valeur du champ formaté en ISO8601 (DateTime).
  datetime: ISO8601DateTime
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

type DecimalNumberChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
  value: Float
}

# Un dossier supprimé
type DeletedDossier {
  # Date de suppression.
  dateSupression: ISO8601DateTime!
  id: ID!

  # Le numéro du dossier qui a été supprimé.
  number: Int!

  # La raison de la suppression du dossier.
  reason: String!

  # L’état du dossier supprimé.
  state: DossierState!
}

# The connection type for DeletedDossier.
type DeletedDossierConnection {
  # A list of edges.
  edges: [DeletedDossierEdge]

  # A list of nodes.
  nodes: [DeletedDossier]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type DeletedDossierEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: DeletedDossier
}

interface Demandeur {
  id: ID!
}

# Une démarche
type Demarche {
  activeRevision: Revision!
  annotationDescriptors: [ChampDescriptor!]!
    @deprecated(
      reason: "Utilisez le champ `activeRevision.annotationDescriptors` à la place."
    )
  champDescriptors: [ChampDescriptor!]!
    @deprecated(
      reason: "Utilisez le champ `activeRevision.champDescriptors` à la place."
    )

  # Date de la création.
  dateCreation: ISO8601DateTime!

  # Date de la dépublication.
  dateDepublication: ISO8601DateTime

  # Date de la dernière modification.
  dateDerniereModification: ISO8601DateTime!

  # Date de la fermeture.
  dateFermeture: ISO8601DateTime

  # Date de la publication.
  datePublication: ISO8601DateTime

  # Pour une démarche déclarative, état cible des dossiers à valider automatiquement
  declarative: DossierDeclarativeState

  # Liste de tous les dossiers supprimés d’une démarche.
  deletedDossiers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # L’ordre des dossiers supprimés.
    order: Order = ASC

    # Dossiers supprimés depuis la date.
    deletedSince: ISO8601DateTime
  ): DeletedDossierConnection!

  # Description de la démarche.
  description: String!

  # Liste de tous les dossiers d’une démarche.
  dossiers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # L’ordre des dossiers.
    order: Order = ASC

    # Dossiers déposés depuis la date.
    createdSince: ISO8601DateTime

    # Dossiers mis à jour depuis la date.
    updatedSince: ISO8601DateTime

    # Dossiers avec statut.
    state: DossierState

    # Seulement les dossiers archivés.
    archived: Boolean

    # Seulement les dossiers pour la révision donnée.
    revision: ID

    # Seulement les dossiers pour les révisons avant la révision donnée.
    maxRevision: ID

    # Seulement les dossiers pour les révisons après la révision donnée.
    minRevision: ID
  ): DossierConnection!
  draftRevision: Revision!
  groupeInstructeurs: [GroupeInstructeur!]!
  id: ID!

  # Numero de la démarche.
  number: Int!
  publishedRevision: Revision
  revisions: [Revision!]!
  service: Service

  # État de la démarche.
  state: DemarcheState!

  # Titre de la démarche.
  title: String!
}

# Une démarche (métadonnées)
# Ceci est une version abrégée du type `Demarche`, qui n’expose que les métadonnées.
# Cela évite l’accès récursif aux dossiers.
type DemarcheDescriptor {
  cadreJuridique: String

  # Date de la création.
  dateCreation: ISO8601DateTime!

  # Date de la dépublication.
  dateDepublication: ISO8601DateTime

  # Date de la dernière modification.
  dateDerniereModification: ISO8601DateTime!

  # Date de la fermeture.
  dateFermeture: ISO8601DateTime

  # Date de la publication.
  datePublication: ISO8601DateTime

  # Pour une démarche déclarative, état cible des dossiers à valider automatiquement
  declarative: DossierDeclarativeState
  deliberation: String

  # Description de la démarche.
  description: String!
  id: ID!

  # Numero de la démarche.
  number: Int!
  revision: Revision!
  service: Service

  # État de la démarche.
  state: DemarcheState!

  # Titre de la démarche.
  title: String!
}

enum DemarcheState {
  # Brouillon
  brouillon

  # Publiée
  publiee

  # Close
  close

  # Depubliee
  depubliee
}

type Departement {
  code: String!
  name: String!
}

# Represents direct upload credentials
type DirectUpload {
  # Created blob record ID
  blobId: ID!

  # HTTP request headers (JSON-encoded)
  headers: String!

  # Created blob record signed ID
  signedBlobId: ID!

  # Upload URL
  url: String!
}

# Un dossier
type Dossier {
  annotations(id: ID): [Champ!]!
  archived: Boolean!

  # L’URL de l’attestation au format PDF.
  attestation: File
  avis(id: ID): [Avis!]!
  champs(id: ID): [Champ!]!

  # Date de dépôt.
  dateDepot: ISO8601DateTime!

  # Date de la dernière modification.
  dateDerniereModification: ISO8601DateTime!

  # Date d’expiration.
  dateExpiration: ISO8601DateTime

  # Date du dernier passage en construction.
  datePassageEnConstruction: ISO8601DateTime!

  # Date du dernier passage en instruction.
  datePassageEnInstruction: ISO8601DateTime

  # Date de la suppression par l’administration.
  dateSuppressionParAdministration: ISO8601DateTime

  # Date de la suppression par l’usager.
  dateSuppressionParUsager: ISO8601DateTime

  # Date du dernier traitement.
  dateTraitement: ISO8601DateTime
  demandeur: Demandeur!
  demarche: DemarcheDescriptor!

  # L’URL du GeoJSON contenant les données cartographiques du dossier.
  geojson: File
  groupeInstructeur: GroupeInstructeur!
  id: ID!
  instructeurs: [Profile!]!
  messages(id: ID): [Message!]!
  motivation: String
  motivationAttachment: File

  # Le numero du dossier.
  number: Int!

  # L’URL du dossier au format PDF.
  pdf: File
  revision: Revision!
    @deprecated(reason: "Utilisez le champ `demarche.revision` à la place.")

  # L’état du dossier.
  state: DossierState!
  traitements: [Traitement!]!
  usager: Profile!
}

# Autogenerated input type of DossierAccepter
input DossierAccepterInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!
  motivation: String
  justificatif: ID

  # Désactiver l’envoi de l’email de notification après l’opération
  disableNotification: Boolean = false

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierAccepter
type DossierAccepterPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# Autogenerated input type of DossierArchiver
input DossierArchiverInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierArchiver
type DossierArchiverPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# Autogenerated input type of DossierChangerGroupeInstructeur
input DossierChangerGroupeInstructeurInput {
  # Dossier ID
  dossierId: ID!

  # Group instructeur a affecter
  groupeInstructeurId: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierChangerGroupeInstructeur
type DossierChangerGroupeInstructeurPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# Autogenerated input type of DossierClasserSansSuite
input DossierClasserSansSuiteInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!
  motivation: String!
  justificatif: ID

  # Désactiver l’envoi de l’email de notification après l’opération
  disableNotification: Boolean = false

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierClasserSansSuite
type DossierClasserSansSuitePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# The connection type for Dossier.
type DossierConnection {
  # A list of edges.
  edges: [DossierEdge]

  # A list of nodes.
  nodes: [Dossier]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

enum DossierDeclarativeState {
  # En instruction
  en_instruction

  # Accepté
  accepte
}

# An edge in a connection.
type DossierEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Dossier
}

# Autogenerated input type of DossierEnvoyerMessage
input DossierEnvoyerMessageInput {
  dossierId: ID!
  instructeurId: ID!
  body: String!
  attachment: ID

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierEnvoyerMessage
type DossierEnvoyerMessagePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
  message: Message
}

type DossierLinkChamp implements Champ {
  dossier: Dossier
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

# Autogenerated input type of DossierModifierAnnotationAjouterLigne
input DossierModifierAnnotationAjouterLigneInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui demande la modification.
  instructeurId: ID!

  # Annotation ID
  annotationId: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierModifierAnnotationAjouterLigne
type DossierModifierAnnotationAjouterLignePayload {
  annotation: RepetitionChamp

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
}

# Autogenerated input type of DossierModifierAnnotationCheckbox
input DossierModifierAnnotationCheckboxInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui demande la modification.
  instructeurId: ID!

  # Annotation ID
  annotationId: ID!
  value: Boolean!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierModifierAnnotationCheckbox
type DossierModifierAnnotationCheckboxPayload {
  annotation: Champ

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
}

# Autogenerated input type of DossierModifierAnnotationDate
input DossierModifierAnnotationDateInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui demande la modification.
  instructeurId: ID!

  # Annotation ID
  annotationId: ID!
  value: ISO8601Date!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierModifierAnnotationDate
type DossierModifierAnnotationDatePayload {
  annotation: Champ

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
}

# Autogenerated input type of DossierModifierAnnotationDatetime
input DossierModifierAnnotationDatetimeInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui demande la modification.
  instructeurId: ID!

  # Annotation ID
  annotationId: ID!
  value: ISO8601DateTime!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierModifierAnnotationDatetime
type DossierModifierAnnotationDatetimePayload {
  annotation: Champ

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
}

# Autogenerated input type of DossierModifierAnnotationIntegerNumber
input DossierModifierAnnotationIntegerNumberInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui demande la modification.
  instructeurId: ID!

  # Annotation ID
  annotationId: ID!
  value: Int!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierModifierAnnotationIntegerNumber
type DossierModifierAnnotationIntegerNumberPayload {
  annotation: Champ

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
}

# Autogenerated input type of DossierModifierAnnotationText
input DossierModifierAnnotationTextInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui demande la modification.
  instructeurId: ID!

  # Annotation ID
  annotationId: ID!
  value: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierModifierAnnotationText
type DossierModifierAnnotationTextPayload {
  annotation: Champ

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  errors: [ValidationError!]
}

# Autogenerated input type of DossierPasserEnInstruction
input DossierPasserEnInstructionInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!

  # Désactiver l’envoi de l’email de notification après l’opération
  disableNotification: Boolean = false

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierPasserEnInstruction
type DossierPasserEnInstructionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# Autogenerated input type of DossierRefuser
input DossierRefuserInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!
  motivation: String!
  justificatif: ID

  # Désactiver l’envoi de l’email de notification après l’opération
  disableNotification: Boolean = false

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierRefuser
type DossierRefuserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# Autogenerated input type of DossierRepasserEnConstruction
input DossierRepasserEnConstructionInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!

  # Désactiver l’envoi de l’email de notification après l’opération
  disableNotification: Boolean = false

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierRepasserEnConstruction
type DossierRepasserEnConstructionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

# Autogenerated input type of DossierRepasserEnInstruction
input DossierRepasserEnInstructionInput {
  # Dossier ID
  dossierId: ID!

  # Instructeur qui prend la décision sur le dossier.
  instructeurId: ID!

  # Désactiver l’envoi de l’email de notification après l’opération
  disableNotification: Boolean = false

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of DossierRepasserEnInstruction
type DossierRepasserEnInstructionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dossier: Dossier
  errors: [ValidationError!]
}

enum DossierState {
  # En construction
  en_construction

  # En instruction
  en_instruction

  # Accepté
  accepte

  # Refusé
  refuse

  # Classé sans suite
  sans_suite
}

type Effectif {
  nb: Float!
  periode: String!
}

type Entreprise {
  attestationFiscaleAttachment: File
  attestationSocialeAttachment: File

  # capital social de l’entreprise. -1 si inconnu.
  capitalSocial: BigInt
  codeEffectifEntreprise: String
  dateCreation: ISO8601Date!

  # effectif moyen d’une année
  effectifAnnuel: Effectif

  # effectif pour un mois donné
  effectifMensuel: Effectif
  etatAdministratif: EntrepriseEtatAdministratif
  formeJuridique: String
  formeJuridiqueCode: String
  inlineAdresse: String!
  nom: String
  nomCommercial: String!
  numeroTvaIntracommunautaire: String
  prenom: String
  raisonSociale: String!
  siren: String!
  siretSiegeSocial: String!
}

enum EntrepriseEtatAdministratif {
  # L'entreprise est en activité
  Actif

  # L'entreprise a cessé son activité
  Ferme
}

type File {
  byteSize: Int!
    @deprecated(reason: "Utilisez le champ `byteSizeBigInt` à la place.")
  byteSizeBigInt: BigInt!
  checksum: String!
  contentType: String!
  filename: String!
  url: URL!
}

interface GeoArea {
  description: String
  geometry: GeoJSON!
  id: ID!
  source: GeoAreaSource!
}

enum GeoAreaSource {
  # Parcelle cadastrale
  cadastre

  # Sélection utilisateur
  selection_utilisateur
}

type GeoJSON {
  coordinates: Coordinates!
  type: String!
}

# Un groupe instructeur
type GroupeInstructeur {
  id: ID!
  instructeurs: [Profile!]!
  label: String!

  # Le numero du groupe instructeur.
  number: Int!
}

# Un groupe instructeur avec ces dossiers
type GroupeInstructeurWithDossiers {
  # Liste de tous les dossiers d’une démarche.
  dossiers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # L’ordre des dossiers.
    order: Order = ASC

    # Dossiers déposés depuis la date.
    createdSince: ISO8601DateTime

    # Dossiers mis à jour depuis la date.
    updatedSince: ISO8601DateTime

    # Dossiers avec statut.
    state: DossierState
  ): DossierConnection!
  id: ID!
  instructeurs: [Profile!]!
  label: String!

  # Le numero du groupe instructeur.
  number: Int!
}

# An ISO 8601-encoded date
scalar ISO8601Date

# An ISO 8601-encoded datetime
scalar ISO8601DateTime

type IntegerNumberChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
  value: BigInt
}

type LinkedDropDownListChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!
  primaryValue: String
  secondaryValue: String

  # La valeur du champ sous forme texte.
  stringValue: String
}

type Message {
  attachment: File
  body: String!
  createdAt: ISO8601DateTime!
  email: String!
  id: ID!
}

type MultipleDropDownListChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
  values: [String!]!
}

type Mutation {
  # File information required to prepare a direct upload
  createDirectUpload(
    # Parameters for CreateDirectUpload
    input: CreateDirectUploadInput!
  ): CreateDirectUploadPayload

  # Accepter le dossier.
  dossierAccepter(
    # Parameters for DossierAccepter
    input: DossierAccepterInput!
  ): DossierAccepterPayload

  # Archiver le dossier.
  dossierArchiver(
    # Parameters for DossierArchiver
    input: DossierArchiverInput!
  ): DossierArchiverPayload

  # Changer le grope instructeur du dossier.
  dossierChangerGroupeInstructeur(
    # Parameters for DossierChangerGroupeInstructeur
    input: DossierChangerGroupeInstructeurInput!
  ): DossierChangerGroupeInstructeurPayload

  # Classer le dossier sans suite.
  dossierClasserSansSuite(
    # Parameters for DossierClasserSansSuite
    input: DossierClasserSansSuiteInput!
  ): DossierClasserSansSuitePayload

  # Envoyer un message à l'usager du dossier.
  dossierEnvoyerMessage(
    # Parameters for DossierEnvoyerMessage
    input: DossierEnvoyerMessageInput!
  ): DossierEnvoyerMessagePayload
  dossierModifierAnnotationAjouterLigne(
    # Parameters for DossierModifierAnnotationAjouterLigne
    input: DossierModifierAnnotationAjouterLigneInput!
  ): DossierModifierAnnotationAjouterLignePayload

  # Modifier l’annotation au format oui/non.
  dossierModifierAnnotationCheckbox(
    # Parameters for DossierModifierAnnotationCheckbox
    input: DossierModifierAnnotationCheckboxInput!
  ): DossierModifierAnnotationCheckboxPayload

  # Modifier l’annotation au format date.
  dossierModifierAnnotationDate(
    # Parameters for DossierModifierAnnotationDate
    input: DossierModifierAnnotationDateInput!
  ): DossierModifierAnnotationDatePayload

  # Modifier l’annotation au format date et heure.
  dossierModifierAnnotationDatetime(
    # Parameters for DossierModifierAnnotationDatetime
    input: DossierModifierAnnotationDatetimeInput!
  ): DossierModifierAnnotationDatetimePayload

  # Modifier l’annotation au format nombre entier.
  dossierModifierAnnotationIntegerNumber(
    # Parameters for DossierModifierAnnotationIntegerNumber
    input: DossierModifierAnnotationIntegerNumberInput!
  ): DossierModifierAnnotationIntegerNumberPayload

  # Modifier l’annotation au format text.
  dossierModifierAnnotationText(
    # Parameters for DossierModifierAnnotationText
    input: DossierModifierAnnotationTextInput!
  ): DossierModifierAnnotationTextPayload

  # Passer le dossier en instruction.
  dossierPasserEnInstruction(
    # Parameters for DossierPasserEnInstruction
    input: DossierPasserEnInstructionInput!
  ): DossierPasserEnInstructionPayload

  # Refuser le dossier.
  dossierRefuser(
    # Parameters for DossierRefuser
    input: DossierRefuserInput!
  ): DossierRefuserPayload

  # Re-passer le dossier en construction.
  dossierRepasserEnConstruction(
    # Parameters for DossierRepasserEnConstruction
    input: DossierRepasserEnConstructionInput!
  ): DossierRepasserEnConstructionPayload

  # Re-passer le dossier en instruction.
  dossierRepasserEnInstruction(
    # Parameters for DossierRepasserEnInstruction
    input: DossierRepasserEnInstructionInput!
  ): DossierRepasserEnInstructionPayload
}

enum Order {
  # L’ordre ascendant.
  ASC

  # L’ordre descendant.
  DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

type ParcelleCadastrale implements GeoArea {
  codeArr: String!
    @deprecated(reason: "Utilisez le champ `prefixe` à la place.")
  codeCom: String!
    @deprecated(reason: "Utilisez le champ `commune` à la place.")
  codeDep: String!
    @deprecated(reason: "Utilisez le champ `commune` à la place.")
  commune: String!
  description: String
  feuille: Int! @deprecated(reason: "L’information n’est plus disponible.")
  geometry: GeoJSON!
  id: ID!
  nomCom: String! @deprecated(reason: "Utilisez le champ `commune` à la place.")
  numero: String!
  prefixe: String!
  section: String!
  source: GeoAreaSource!
  surface: String!
  surfaceIntersection: Float!
    @deprecated(reason: "L’information n’est plus disponible.")
  surfaceParcelle: Float!
    @deprecated(reason: "Utilisez le champ `surface` à la place.")
}

type PersonneMorale implements Demandeur {
  address: Address!
  adresse: String!
    @deprecated(reason: "Utilisez le champ `address.label` à la place.")
  association: Association
  codeInseeLocalite: String!
    @deprecated(reason: "Utilisez le champ `address.city_code` à la place.")
  codePostal: String!
    @deprecated(reason: "Utilisez le champ `address.postal_code` à la place.")
  complementAdresse: String
    @deprecated(reason: "Utilisez le champ `address` à la place.")
  entreprise: Entreprise
  id: ID!
  libelleNaf: String!
  localite: String!
    @deprecated(reason: "Utilisez le champ `address.city_name` à la place.")
  naf: String!
  nomVoie: String
    @deprecated(reason: "Utilisez le champ `address.street_name` à la place.")
  numeroVoie: String
    @deprecated(reason: "Utilisez le champ `address.street_number` à la place.")
  siegeSocial: Boolean!
  siret: String!
  typeVoie: String
    @deprecated(
      reason: "Utilisez le champ `address.street_address` à la place."
    )
}

type PersonnePhysique implements Demandeur {
  civilite: Civilite
  dateDeNaissance: ISO8601Date
  id: ID!
  nom: String!
  prenom: String!
}

type PieceJustificativeChamp implements Champ {
  file: File
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

type Profile {
  email: String!
  id: ID!
}

type Query {
  # Informations concernant une démarche.
  demarche(
    # Numéro de la démarche.
    number: Int!
  ): Demarche!

  # Informations sur un dossier d’une démarche.
  dossier(
    # Numéro du dossier.
    number: Int!
  ): Dossier!

  # Informations sur un groupe instructeur.
  groupeInstructeur(
    # Numéro du groupe instructeur.
    number: Int!
  ): GroupeInstructeurWithDossiers!
}

type RepetitionChamp implements Champ {
  champs: [Champ!]!
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

type Revision {
  annotationDescriptors: [ChampDescriptor!]!
  champDescriptors: [ChampDescriptor!]!

  # Date de la création.
  dateCreation: ISO8601DateTime!

  # Date de la publication.
  datePublication: ISO8601DateTime
  id: ID!
}

type SelectionUtilisateur implements GeoArea {
  description: String
  geometry: GeoJSON!
  id: ID!
  source: GeoAreaSource!
}

type Service {
  id: ID!
  nom: String!
  organisme: String!
  siret: String
  typeOrganisme: TypeOrganisme!
}

type SiretChamp implements Champ {
  etablissement: PersonneMorale
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

type TextChamp implements Champ {
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
  value: String
}

type TitreIdentiteChamp implements Champ {
  grantType: TitreIdentiteGrantType!
  id: ID!

  # Libellé du champ.
  label: String!

  # La valeur du champ sous forme texte.
  stringValue: String
}

enum TitreIdentiteGrantType {
  # Françe Connect
  france_connect

  # Pièce justificative
  piece_justificative
}

type Traitement {
  dateTraitement: ISO8601DateTime!
  emailAgentTraitant: String
  id: ID!
  motivation: String
  state: DossierState!
}

enum TypeDeChamp {
  # Texte
  text

  # Zone de texte
  textarea

  # Date
  date

  # Date et Heure
  datetime

  # Nombre
  number

  # Nombre décimal
  decimal_number

  # Nombre entier
  integer_number

  # Case à cocher
  checkbox

  # Civilité
  civilite

  # Email
  email

  # Téléphone
  phone

  # Adresse
  address

  # Oui/Non
  yes_no

  # Choix unique
  drop_down_list

  # Choix multiples
  multiple_drop_down_list

  # Deux menus déroulants liés
  linked_drop_down_list

  # Pays
  pays

  # Régions
  regions

  # Départements
  departements

  # Communes
  communes

  # Engagement
  engagement

  # Titre de section
  header_section

  # Explication
  explication

  # Lien vers un autre dossier
  dossier_link

  # Pièce justificative
  piece_justificative

  # SIRET
  siret

  # Carte
  carte

  # Bloc répétable
  repetition

  # Titre identité
  titre_identite

  # Iban
  iban

  # Annuaire de l’éducation
  annuaire_education

  # Données de la Caisse nationale des allocations familiales
  cnaf

  # Données de la Direction générale des Finances publiques
  dgfip

  # Situation Pôle emploi
  pole_emploi

  # Données du Ministère de l'Enseignement Supérieur, de la Recherche et de l'Innovation
  mesri
}

enum TypeOrganisme {
  # Administration centrale
  administration_centrale

  # Association
  association

  # Collectivité territoriale
  collectivite_territoriale

  # Établissement d’enseignement
  etablissement_enseignement

  # Opérateur d’État
  operateur_d_etat

  # Service déconcentré de l’État
  service_deconcentre_de_l_etat

  # Autre
  autre
}

# A valid URL, transported as a string
scalar URL

# Éreur de validation
type ValidationError {
  # A description of the error
  message: String!
}
